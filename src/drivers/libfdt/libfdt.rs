/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 3412;
pub const BIG_ENDIAN: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const ARGV_MAGIC: u32 = 1600221799;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const FDT_MAGIC: u32 = 3490578157;
pub const FDT_BEGIN_NODE: u32 = 1;
pub const FDT_END_NODE: u32 = 2;
pub const FDT_PROP: u32 = 3;
pub const FDT_NOP: u32 = 4;
pub const FDT_END: u32 = 9;
pub const FDT_FIRST_SUPPORTED_VERSION: u32 = 16;
pub const FDT_LAST_SUPPORTED_VERSION: u32 = 17;
pub const FDT_ERR_NOTFOUND: u32 = 1;
pub const FDT_ERR_EXISTS: u32 = 2;
pub const FDT_ERR_NOSPACE: u32 = 3;
pub const FDT_ERR_BADOFFSET: u32 = 4;
pub const FDT_ERR_BADPATH: u32 = 5;
pub const FDT_ERR_BADPHANDLE: u32 = 6;
pub const FDT_ERR_BADSTATE: u32 = 7;
pub const FDT_ERR_TRUNCATED: u32 = 8;
pub const FDT_ERR_BADMAGIC: u32 = 9;
pub const FDT_ERR_BADVERSION: u32 = 10;
pub const FDT_ERR_BADSTRUCTURE: u32 = 11;
pub const FDT_ERR_BADLAYOUT: u32 = 12;
pub const FDT_ERR_INTERNAL: u32 = 13;
pub const FDT_ERR_MAX: u32 = 13;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u8_ = u8;
pub type u16_ = u16;
pub type u32_ = u32;
pub type u64_ = u64;
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type vu8 = u8_;
pub type vu16 = u16_;
pub type vu32 = u32_;
pub type vu64 = u64_;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type sfp16 = s16;
pub type sfp32 = s32;
pub type ufp16 = u16_;
pub type ufp32 = u32_;
pub type f32_ = f32;
pub type f64_ = f64;
pub type vf32 = f32;
pub type vf64 = f64;
pub type lba_t = ::std::os::raw::c_ulonglong;
pub type BOOL = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __argv {
    pub magic: ::std::os::raw::c_int,
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __argv"][::std::mem::size_of::<__argv>() - 16usize];
    ["Alignment of __argv"][::std::mem::align_of::<__argv>() - 8usize];
    ["Offset of field: __argv::magic"][::std::mem::offset_of!(__argv, magic) - 0usize];
    ["Offset of field: __argv::argc"][::std::mem::offset_of!(__argv, argc) - 4usize];
    ["Offset of field: __argv::argv"][::std::mem::offset_of!(__argv, argv) - 8usize];
};
unsafe extern "C" {
    pub static mut __system_argv: *mut __argv;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdt_header {
    pub magic: u32,
    pub totalsize: u32,
    pub off_dt_struct: u32,
    pub off_dt_strings: u32,
    pub off_mem_rsvmap: u32,
    pub version: u32,
    pub last_comp_version: u32,
    pub boot_cpuid_phys: u32,
    pub size_dt_strings: u32,
    pub size_dt_struct: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fdt_header"][::std::mem::size_of::<fdt_header>() - 40usize];
    ["Alignment of fdt_header"][::std::mem::align_of::<fdt_header>() - 4usize];
    ["Offset of field: fdt_header::magic"][::std::mem::offset_of!(fdt_header, magic) - 0usize];
    ["Offset of field: fdt_header::totalsize"]
        [::std::mem::offset_of!(fdt_header, totalsize) - 4usize];
    ["Offset of field: fdt_header::off_dt_struct"]
        [::std::mem::offset_of!(fdt_header, off_dt_struct) - 8usize];
    ["Offset of field: fdt_header::off_dt_strings"]
        [::std::mem::offset_of!(fdt_header, off_dt_strings) - 12usize];
    ["Offset of field: fdt_header::off_mem_rsvmap"]
        [::std::mem::offset_of!(fdt_header, off_mem_rsvmap) - 16usize];
    ["Offset of field: fdt_header::version"][::std::mem::offset_of!(fdt_header, version) - 20usize];
    ["Offset of field: fdt_header::last_comp_version"]
        [::std::mem::offset_of!(fdt_header, last_comp_version) - 24usize];
    ["Offset of field: fdt_header::boot_cpuid_phys"]
        [::std::mem::offset_of!(fdt_header, boot_cpuid_phys) - 28usize];
    ["Offset of field: fdt_header::size_dt_strings"]
        [::std::mem::offset_of!(fdt_header, size_dt_strings) - 32usize];
    ["Offset of field: fdt_header::size_dt_struct"]
        [::std::mem::offset_of!(fdt_header, size_dt_struct) - 36usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdt_reserve_entry {
    pub address: u64,
    pub size: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fdt_reserve_entry"][::std::mem::size_of::<fdt_reserve_entry>() - 16usize];
    ["Alignment of fdt_reserve_entry"][::std::mem::align_of::<fdt_reserve_entry>() - 8usize];
    ["Offset of field: fdt_reserve_entry::address"]
        [::std::mem::offset_of!(fdt_reserve_entry, address) - 0usize];
    ["Offset of field: fdt_reserve_entry::size"]
        [::std::mem::offset_of!(fdt_reserve_entry, size) - 8usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct fdt_node_header {
    pub tag: u32,
    pub name: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fdt_node_header"][::std::mem::size_of::<fdt_node_header>() - 4usize];
    ["Alignment of fdt_node_header"][::std::mem::align_of::<fdt_node_header>() - 4usize];
    ["Offset of field: fdt_node_header::tag"]
        [::std::mem::offset_of!(fdt_node_header, tag) - 0usize];
    ["Offset of field: fdt_node_header::name"]
        [::std::mem::offset_of!(fdt_node_header, name) - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct fdt_property {
    pub tag: u32,
    pub len: u32,
    pub nameoff: u32,
    pub data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fdt_property"][::std::mem::size_of::<fdt_property>() - 12usize];
    ["Alignment of fdt_property"][::std::mem::align_of::<fdt_property>() - 4usize];
    ["Offset of field: fdt_property::tag"][::std::mem::offset_of!(fdt_property, tag) - 0usize];
    ["Offset of field: fdt_property::len"][::std::mem::offset_of!(fdt_property, len) - 4usize];
    ["Offset of field: fdt_property::nameoff"]
        [::std::mem::offset_of!(fdt_property, nameoff) - 8usize];
    ["Offset of field: fdt_property::data"][::std::mem::offset_of!(fdt_property, data) - 12usize];
};
unsafe extern "C" {
    pub fn fdt_offset_ptr(
        fdt: *const ::std::os::raw::c_void,
        offset: ::std::os::raw::c_int,
        checklen: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn fdt_next_tag(
        fdt: *const ::std::os::raw::c_void,
        offset: ::std::os::raw::c_int,
        nextoffset: *mut ::std::os::raw::c_int,
    ) -> u32;
}
unsafe extern "C" {
    pub fn fdt_next_node(
        fdt: *const ::std::os::raw::c_void,
        offset: ::std::os::raw::c_int,
        depth: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_check_header - sanity check a device tree or possible device tree\n @fdt: pointer to data which might be a flattened device tree\n\n fdt_check_header() checks that the given buffer contains what\n appears to be a flattened device tree with sane information in its\n header.\n\n returns:\n     0, if the buffer appears to contain a valid device tree\n     -FDT_ERR_BADMAGIC,\n     -FDT_ERR_BADVERSION,\n     -FDT_ERR_BADSTATE, standard meanings, as above"]
    pub fn fdt_check_header(fdt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_move - move a device tree around in memory\n @fdt: pointer to the device tree to move\n @buf: pointer to memory where the device is to be moved\n @bufsize: size of the memory space at buf\n\n fdt_move() relocates, if possible, the device tree blob located at\n fdt to the buffer at buf of size bufsize.  The buffer may overlap\n with the existing device tree blob at fdt.  Therefore,\n     fdt_move(fdt, fdt, fdt_totalsize(fdt))\n should always succeed.\n\n returns:\n     0, on success\n     -FDT_ERR_NOSPACE, bufsize is insufficient to contain the device tree\n     -FDT_ERR_BADMAGIC,\n     -FDT_ERR_BADVERSION,\n     -FDT_ERR_BADSTATE, standard meanings"]
    pub fn fdt_move(
        fdt: *const ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        bufsize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_string - retrieve a string from the strings block of a device tree\n @fdt: pointer to the device tree blob\n @stroffset: offset of the string within the strings block (native endian)\n\n fdt_string() retrieves a pointer to a single string from the\n strings block of the device tree blob at fdt.\n\n returns:\n     a pointer to the string, on success\n     NULL, if stroffset is out of bounds"]
    pub fn fdt_string(
        fdt: *const ::std::os::raw::c_void,
        stroffset: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_num_mem_rsv - retrieve the number of memory reserve map entries\n @fdt: pointer to the device tree blob\n\n Returns the number of entries in the device tree blob's memory\n reservation map.  This does not include the terminating 0,0 entry\n or any other (0,0) entries reserved for expansion.\n\n returns:\n     the number of entries"]
    pub fn fdt_num_mem_rsv(fdt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_get_mem_rsv - retrieve one memory reserve map entry\n @fdt: pointer to the device tree blob\n @address, @size: pointers to 64-bit variables\n\n On success, *address and *size will contain the address and size of\n the n-th reserve map entry from the device tree blob, in\n native-endian format.\n\n returns:\n     0, on success\n     -FDT_ERR_BADMAGIC,\n     -FDT_ERR_BADVERSION,\n     -FDT_ERR_BADSTATE, standard meanings"]
    pub fn fdt_get_mem_rsv(
        fdt: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        address: *mut u64,
        size: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_subnode_offset_namelen - find a subnode based on substring\n @fdt: pointer to the device tree blob\n @parentoffset: structure block offset of a node\n @name: name of the subnode to locate\n @namelen: number of characters of name to consider\n\n Identical to fdt_subnode_offset(), but only examine the first\n namelen characters of name for matching the subnode name.  This is\n useful for finding subnodes based on a portion of a larger string,\n such as a full path."]
    pub fn fdt_subnode_offset_namelen(
        fdt: *const ::std::os::raw::c_void,
        parentoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        namelen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_subnode_offset - find a subnode of a given node\n @fdt: pointer to the device tree blob\n @parentoffset: structure block offset of a node\n @name: name of the subnode to locate\n\n fdt_subnode_offset() finds a subnode of the node at structure block\n offset parentoffset with the given name.  name may include a unit\n address, in which case fdt_subnode_offset() will find the subnode\n with that unit address, or the unit address may be omitted, in\n which case fdt_subnode_offset() will find an arbitrary subnode\n whose name excluding unit address matches the given name.\n\n returns:\n\tstructure block offset of the requested subnode (>=0), on success\n\t-FDT_ERR_NOTFOUND, if the requested subnode does not exist\n\t-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE tag\n      -FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings."]
    pub fn fdt_subnode_offset(
        fdt: *const ::std::os::raw::c_void,
        parentoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_path_offset - find a tree node by its full path\n @fdt: pointer to the device tree blob\n @path: full path of the node to locate\n\n fdt_path_offset() finds a node of a given path in the device tree.\n Each path component may omit the unit address portion, but the\n results of this are undefined if any such path component is\n ambiguous (that is if there are multiple nodes at the relevant\n level matching the given component, differentiated only by unit\n address).\n\n returns:\n\tstructure block offset of the node with the requested path (>=0), on success\n\t-FDT_ERR_BADPATH, given path does not begin with '/' or is invalid\n\t-FDT_ERR_NOTFOUND, if the requested node does not exist\n      -FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings."]
    pub fn fdt_path_offset(
        fdt: *const ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_get_name - retrieve the name of a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: structure block offset of the starting node\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_get_name() retrieves the name (including unit address) of the\n device tree node at structure block offset nodeoffset.  If lenp is\n non-NULL, the length of this name is also returned, in the integer\n pointed to by lenp.\n\n returns:\n\tpointer to the node's name, on success\n\t\tIf lenp is non-NULL, *lenp contains the length of that name (>=0)\n\tNULL, on error\n\t\tif lenp is non-NULL *lenp contains an error code (<0):\n\t\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t\t-FDT_ERR_BADMAGIC,\n\t\t-FDT_ERR_BADVERSION,\n\t\t-FDT_ERR_BADSTATE, standard meanings"]
    pub fn fdt_get_name(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        lenp: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_first_property_offset - find the offset of a node's first property\n @fdt: pointer to the device tree blob\n @nodeoffset: structure block offset of a node\n\n fdt_first_property_offset() finds the first property of the node at\n the given structure block offset.\n\n returns:\n\tstructure block offset of the property (>=0), on success\n\t-FDT_ERR_NOTFOUND, if the requested node has no properties\n\t-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_BEGIN_NODE tag\n      -FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings."]
    pub fn fdt_first_property_offset(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_next_property_offset - step through a node's properties\n @fdt: pointer to the device tree blob\n @offset: structure block offset of a property\n\n fdt_next_property_offset() finds the property immediately after the\n one at the given structure block offset.  This will be a property\n of the same node as the given property.\n\n returns:\n\tstructure block offset of the next property (>=0), on success\n\t-FDT_ERR_NOTFOUND, if the given property is the last in its node\n\t-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_PROP tag\n      -FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings."]
    pub fn fdt_next_property_offset(
        fdt: *const ::std::os::raw::c_void,
        offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_get_property_by_offset - retrieve the property at a given offset\n @fdt: pointer to the device tree blob\n @offset: offset of the property to retrieve\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_get_property_by_offset() retrieves a pointer to the\n fdt_property structure within the device tree blob at the given\n offset.  If lenp is non-NULL, the length of the property value is\n also returned, in the integer pointed to by lenp.\n\n returns:\n\tpointer to the structure representing the property\n\t\tif lenp is non-NULL, *lenp contains the length of the property\n\t\tvalue (>=0)\n\tNULL, on error\n\t\tif lenp is non-NULL, *lenp contains an error code (<0):\n\t\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag\n\t\t-FDT_ERR_BADMAGIC,\n\t\t-FDT_ERR_BADVERSION,\n\t\t-FDT_ERR_BADSTATE,\n\t\t-FDT_ERR_BADSTRUCTURE,\n\t\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_get_property_by_offset(
        fdt: *const ::std::os::raw::c_void,
        offset: ::std::os::raw::c_int,
        lenp: *mut ::std::os::raw::c_int,
    ) -> *const fdt_property;
}
unsafe extern "C" {
    #[doc = " fdt_get_property_namelen - find a property based on substring\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to find\n @name: name of the property to find\n @namelen: number of characters of name to consider\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n Identical to fdt_get_property_namelen(), but only examine the first\n namelen characters of name for matching the property name."]
    pub fn fdt_get_property_namelen(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        namelen: ::std::os::raw::c_int,
        lenp: *mut ::std::os::raw::c_int,
    ) -> *const fdt_property;
}
unsafe extern "C" {
    #[doc = " fdt_get_property - find a given property in a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to find\n @name: name of the property to find\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_get_property() retrieves a pointer to the fdt_property\n structure within the device tree blob corresponding to the property\n named 'name' of the node at offset nodeoffset.  If lenp is\n non-NULL, the length of the property value is also returned, in the\n integer pointed to by lenp.\n\n returns:\n\tpointer to the structure representing the property\n\t\tif lenp is non-NULL, *lenp contains the length of the property\n\t\tvalue (>=0)\n\tNULL, on error\n\t\tif lenp is non-NULL, *lenp contains an error code (<0):\n\t\t-FDT_ERR_NOTFOUND, node does not have named property\n\t\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t\t-FDT_ERR_BADMAGIC,\n\t\t-FDT_ERR_BADVERSION,\n\t\t-FDT_ERR_BADSTATE,\n\t\t-FDT_ERR_BADSTRUCTURE,\n\t\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_get_property(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        lenp: *mut ::std::os::raw::c_int,
    ) -> *const fdt_property;
}
unsafe extern "C" {
    #[doc = " fdt_getprop_by_offset - retrieve the value of a property at a given offset\n @fdt: pointer to the device tree blob\n @ffset: offset of the property to read\n @namep: pointer to a string variable (will be overwritten) or NULL\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_getprop_by_offset() retrieves a pointer to the value of the\n property at structure block offset 'offset' (this will be a pointer\n to within the device blob itself, not a copy of the value).  If\n lenp is non-NULL, the length of the property value is also\n returned, in the integer pointed to by lenp.  If namep is non-NULL,\n the property's namne will also be returned in the char * pointed to\n by namep (this will be a pointer to within the device tree's string\n block, not a new copy of the name).\n\n returns:\n\tpointer to the property's value\n\t\tif lenp is non-NULL, *lenp contains the length of the property\n\t\tvalue (>=0)\n\t\tif namep is non-NULL *namep contiains a pointer to the property\n\t\tname.\n\tNULL, on error\n\t\tif lenp is non-NULL, *lenp contains an error code (<0):\n\t\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag\n\t\t-FDT_ERR_BADMAGIC,\n\t\t-FDT_ERR_BADVERSION,\n\t\t-FDT_ERR_BADSTATE,\n\t\t-FDT_ERR_BADSTRUCTURE,\n\t\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_getprop_by_offset(
        fdt: *const ::std::os::raw::c_void,
        offset: ::std::os::raw::c_int,
        namep: *mut *const ::std::os::raw::c_char,
        lenp: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " fdt_getprop_namelen - get property value based on substring\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to find\n @name: name of the property to find\n @namelen: number of characters of name to consider\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n Identical to fdt_getprop(), but only examine the first namelen\n characters of name for matching the property name."]
    pub fn fdt_getprop_namelen(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        namelen: ::std::os::raw::c_int,
        lenp: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " fdt_getprop - retrieve the value of a given property\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to find\n @name: name of the property to find\n @lenp: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_getprop() retrieves a pointer to the value of the property\n named 'name' of the node at offset nodeoffset (this will be a\n pointer to within the device blob itself, not a copy of the value).\n If lenp is non-NULL, the length of the property value is also\n returned, in the integer pointed to by lenp.\n\n returns:\n\tpointer to the property's value\n\t\tif lenp is non-NULL, *lenp contains the length of the property\n\t\tvalue (>=0)\n\tNULL, on error\n\t\tif lenp is non-NULL, *lenp contains an error code (<0):\n\t\t-FDT_ERR_NOTFOUND, node does not have named property\n\t\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t\t-FDT_ERR_BADMAGIC,\n\t\t-FDT_ERR_BADVERSION,\n\t\t-FDT_ERR_BADSTATE,\n\t\t-FDT_ERR_BADSTRUCTURE,\n\t\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_getprop(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        lenp: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " fdt_get_phandle - retrieve the phandle of a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: structure block offset of the node\n\n fdt_get_phandle() retrieves the phandle of the device tree node at\n structure block offset nodeoffset.\n\n returns:\n\tthe phandle of the node at nodeoffset, on success (!= 0, != -1)\n\t0, if the node has no phandle, or another error occurs"]
    pub fn fdt_get_phandle(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " fdt_get_alias_namelen - get alias based on substring\n @fdt: pointer to the device tree blob\n @name: name of the alias th look up\n @namelen: number of characters of name to consider\n\n Identical to fdt_get_alias(), but only examine the first namelen\n characters of name for matching the alias name."]
    pub fn fdt_get_alias_namelen(
        fdt: *const ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        namelen: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_get_alias - retreive the path referenced by a given alias\n @fdt: pointer to the device tree blob\n @name: name of the alias th look up\n\n fdt_get_alias() retrieves the value of a given alias.  That is, the\n value of the property named 'name' in the node /aliases.\n\n returns:\n\ta pointer to the expansion of the alias named 'name', of it exists\n\tNULL, if the given alias or the /aliases node does not exist"]
    pub fn fdt_get_alias(
        fdt: *const ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " fdt_get_path - determine the full path of a node\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose path to find\n @buf: character buffer to contain the returned path (will be overwritten)\n @buflen: size of the character buffer at buf\n\n fdt_get_path() computes the full path of the node at offset\n nodeoffset, and records that path in the buffer at buf.\n\n NOTE: This function is expensive, as it must scan the device tree\n structure from the start to nodeoffset.\n\n returns:\n\t0, on success\n\t\tbuf contains the absolute path of the node at\n\t\tnodeoffset, as a NUL-terminated string.\n \t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_NOSPACE, the path of the given node is longer than (bufsize-1)\n\t\tcharacters and will not fit in the given buffer.\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_get_path(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_supernode_atdepth_offset - find a specific ancestor of a node\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose parent to find\n @supernodedepth: depth of the ancestor to find\n @nodedepth: pointer to an integer variable (will be overwritten) or NULL\n\n fdt_supernode_atdepth_offset() finds an ancestor of the given node\n at a specific depth from the root (where the root itself has depth\n 0, its immediate subnodes depth 1 and so forth).  So\n\tfdt_supernode_atdepth_offset(fdt, nodeoffset, 0, NULL);\n will always return 0, the offset of the root node.  If the node at\n nodeoffset has depth D, then:\n\tfdt_supernode_atdepth_offset(fdt, nodeoffset, D, NULL);\n will return nodeoffset itself.\n\n NOTE: This function is expensive, as it must scan the device tree\n structure from the start to nodeoffset.\n\n returns:\n\n\tstructure block offset of the node at node offset's ancestor\n\t\tof depth supernodedepth (>=0), on success\n \t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_NOTFOUND, supernodedepth was greater than the depth of nodeoffset\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_supernode_atdepth_offset(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        supernodedepth: ::std::os::raw::c_int,
        nodedepth: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_node_depth - find the depth of a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose parent to find\n\n fdt_node_depth() finds the depth of a given node.  The root node\n has depth 0, its immediate subnodes depth 1 and so forth.\n\n NOTE: This function is expensive, as it must scan the device tree\n structure from the start to nodeoffset.\n\n returns:\n\tdepth of the node at nodeoffset (>=0), on success\n \t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_node_depth(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_parent_offset - find the parent of a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose parent to find\n\n fdt_parent_offset() locates the parent node of a given node (that\n is, it finds the offset of the node which contains the node at\n nodeoffset as a subnode).\n\n NOTE: This function is expensive, as it must scan the device tree\n structure from the start to nodeoffset, *twice*.\n\n returns:\n\tstructure block offset of the parent of the node at nodeoffset\n\t\t(>=0), on success\n \t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_parent_offset(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_node_offset_by_prop_value - find nodes with a given property value\n @fdt: pointer to the device tree blob\n @startoffset: only find nodes after this offset\n @propname: property name to check\n @propval: property value to search for\n @proplen: length of the value in propval\n\n fdt_node_offset_by_prop_value() returns the offset of the first\n node after startoffset, which has a property named propname whose\n value is of length proplen and has value equal to propval; or if\n startoffset is -1, the very first such node in the tree.\n\n To iterate through all nodes matching the criterion, the following\n idiom can be used:\n\toffset = fdt_node_offset_by_prop_value(fdt, -1, propname,\n\t\t\t\t\t       propval, proplen);\n\twhile (offset != -FDT_ERR_NOTFOUND) {\n\t\t// other code here\n\t\toffset = fdt_node_offset_by_prop_value(fdt, offset, propname,\n\t\t\t\t\t\t       propval, proplen);\n\t}\n\n Note the -1 in the first call to the function, if 0 is used here\n instead, the function will never locate the root node, even if it\n matches the criterion.\n\n returns:\n\tstructure block offset of the located node (>= 0, >startoffset),\n\t\t on success\n\t-FDT_ERR_NOTFOUND, no node matching the criterion exists in the\n\t\ttree after startoffset\n \t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_node_offset_by_prop_value(
        fdt: *const ::std::os::raw::c_void,
        startoffset: ::std::os::raw::c_int,
        propname: *const ::std::os::raw::c_char,
        propval: *const ::std::os::raw::c_void,
        proplen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_node_offset_by_phandle - find the node with a given phandle\n @fdt: pointer to the device tree blob\n @phandle: phandle value\n\n fdt_node_offset_by_phandle() returns the offset of the node\n which has the given phandle value.  If there is more than one node\n in the tree with the given phandle (an invalid tree), results are\n undefined.\n\n returns:\n\tstructure block offset of the located node (>= 0), on success\n\t-FDT_ERR_NOTFOUND, no node with that phandle exists\n\t-FDT_ERR_BADPHANDLE, given phandle value was invalid (0 or -1)\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_node_offset_by_phandle(
        fdt: *const ::std::os::raw::c_void,
        phandle: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_node_check_compatible: check a node's compatible property\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of a tree node\n @compatible: string to match against\n\n\n fdt_node_check_compatible() returns 0 if the given node contains a\n 'compatible' property with the given string as one of its elements,\n it returns non-zero otherwise, or on error.\n\n returns:\n\t0, if the node has a 'compatible' property listing the given string\n\t1, if the node has a 'compatible' property, but it does not list\n\t\tthe given string\n\t-FDT_ERR_NOTFOUND, if the given node has no 'compatible' property\n \t-FDT_ERR_BADOFFSET, if nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_node_check_compatible(
        fdt: *const ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        compatible: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_node_offset_by_compatible - find nodes with a given 'compatible' value\n @fdt: pointer to the device tree blob\n @startoffset: only find nodes after this offset\n @compatible: 'compatible' string to match against\n\n fdt_node_offset_by_compatible() returns the offset of the first\n node after startoffset, which has a 'compatible' property which\n lists the given compatible string; or if startoffset is -1, the\n very first such node in the tree.\n\n To iterate through all nodes matching the criterion, the following\n idiom can be used:\n\toffset = fdt_node_offset_by_compatible(fdt, -1, compatible);\n\twhile (offset != -FDT_ERR_NOTFOUND) {\n\t\t// other code here\n\t\toffset = fdt_node_offset_by_compatible(fdt, offset, compatible);\n\t}\n\n Note the -1 in the first call to the function, if 0 is used here\n instead, the function will never locate the root node, even if it\n matches the criterion.\n\n returns:\n\tstructure block offset of the located node (>= 0, >startoffset),\n\t\t on success\n\t-FDT_ERR_NOTFOUND, no node matching the criterion exists in the\n\t\ttree after startoffset\n \t-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE, standard meanings"]
    pub fn fdt_node_offset_by_compatible(
        fdt: *const ::std::os::raw::c_void,
        startoffset: ::std::os::raw::c_int,
        compatible: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_setprop_inplace - change a property's value, but not its size\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to change\n @name: name of the property to change\n @val: pointer to data to replace the property value with\n @len: length of the property value\n\n fdt_setprop_inplace() replaces the value of a given property with\n the data in val, of length len.  This function cannot change the\n size of a property, and so will only work if len is equal to the\n current length of the property.\n\n This function will alter only the bytes in the blob which contain\n the given property value, and will not alter or move any other part\n of the tree.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, if len is not equal to the property's current length\n\t-FDT_ERR_NOTFOUND, node does not have the named property\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_setprop_inplace(
        fdt: *mut ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_nop_property - replace a property with nop tags\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to nop\n @name: name of the property to nop\n\n fdt_nop_property() will replace a given property's representation\n in the blob with FDT_NOP tags, effectively removing it from the\n tree.\n\n This function will alter only the bytes in the blob which contain\n the property, and will not alter or move any other part of the\n tree.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOTFOUND, node does not have the named property\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_nop_property(
        fdt: *mut ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_nop_node - replace a node (subtree) with nop tags\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node to nop\n\n fdt_nop_node() will replace a given node's representation in the\n blob, including all its subnodes, if any, with FDT_NOP tags,\n effectively removing it from the tree.\n\n This function will alter only the bytes in the blob which contain\n the node and its properties and subnodes, and will not alter or\n move any other part of the tree.\n\n returns:\n\t0, on success\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_nop_node(
        fdt: *mut ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdt_create(
        buf: *mut ::std::os::raw::c_void,
        bufsize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdt_add_reservemap_entry(
        fdt: *mut ::std::os::raw::c_void,
        addr: u64,
        size: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdt_finish_reservemap(fdt: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdt_begin_node(
        fdt: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdt_property(
        fdt: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdt_end_node(fdt: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdt_finish(fdt: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdt_open_into(
        fdt: *const ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        bufsize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdt_pack(fdt: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_add_mem_rsv - add one memory reserve map entry\n @fdt: pointer to the device tree blob\n @address, @size: 64-bit values (native endian)\n\n Adds a reserve map entry to the given blob reserving a region at\n address address of length size.\n\n This function will insert data into the reserve map and will\n therefore change the indexes of some entries in the table.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, there is insufficient free space in the blob to\n\t\tcontain the new reservation entry\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_add_mem_rsv(
        fdt: *mut ::std::os::raw::c_void,
        address: u64,
        size: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_del_mem_rsv - remove a memory reserve map entry\n @fdt: pointer to the device tree blob\n @n: entry to remove\n\n fdt_del_mem_rsv() removes the n-th memory reserve map entry from\n the blob.\n\n This function will delete data from the reservation table and will\n therefore change the indexes of some entries in the table.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOTFOUND, there is no entry of the given index (i.e. there\n\t\tare less than n+1 reserve map entries)\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_del_mem_rsv(
        fdt: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_set_name - change the name of a given node\n @fdt: pointer to the device tree blob\n @nodeoffset: structure block offset of a node\n @name: name to give the node\n\n fdt_set_name() replaces the name (including unit address, if any)\n of the given node with the given string.  NOTE: this function can't\n efficiently check if the new name is unique amongst the given\n node's siblings; results are undefined if this function is invoked\n with a name equal to one of the given node's siblings.\n\n This function may insert or delete data from the blob, and will\n therefore change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, there is insufficient free space in the blob\n\t\tto contain the new name\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE, standard meanings"]
    pub fn fdt_set_name(
        fdt: *mut ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_setprop - create or change a property\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to change\n @name: name of the property to change\n @val: pointer to data to set the property value to\n @len: length of the property value\n\n fdt_setprop() sets the value of the named property in the given\n node to the given value and length, creating the property if it\n does not already exist.\n\n This function may insert or delete data from the blob, and will\n therefore change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOSPACE, there is insufficient free space in the blob to\n\t\tcontain the new property value\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_setprop(
        fdt: *mut ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_delprop - delete a property\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node whose property to nop\n @name: name of the property to nop\n\n fdt_del_property() will delete the given property.\n\n This function will delete data from the blob, and will therefore\n change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_NOTFOUND, node does not have the named property\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_delprop(
        fdt: *mut ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_add_subnode_namelen - creates a new node based on substring\n @fdt: pointer to the device tree blob\n @parentoffset: structure block offset of a node\n @name: name of the subnode to locate\n @namelen: number of characters of name to consider\n\n Identical to fdt_add_subnode(), but use only the first namelen\n characters of name as the name of the new node.  This is useful for\n creating subnodes based on a portion of a larger string, such as a\n full path."]
    pub fn fdt_add_subnode_namelen(
        fdt: *mut ::std::os::raw::c_void,
        parentoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        namelen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_add_subnode - creates a new node\n @fdt: pointer to the device tree blob\n @parentoffset: structure block offset of a node\n @name: name of the subnode to locate\n\n fdt_add_subnode() creates a new node as a subnode of the node at\n structure block offset parentoffset, with the given name (which\n should include the unit address, if any).\n\n This function will insert data into the blob, and will therefore\n change the offsets of some existing nodes.\n\n returns:\n\tstructure block offset of the created nodeequested subnode (>=0), on success\n\t-FDT_ERR_NOTFOUND, if the requested subnode does not exist\n\t-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE tag\n\t-FDT_ERR_EXISTS, if the node at parentoffset already has a subnode of\n\t\tthe given name\n\t-FDT_ERR_NOSPACE, if there is insufficient free space in the\n\t\tblob to contain the new node\n\t-FDT_ERR_NOSPACE\n\t-FDT_ERR_BADLAYOUT\n      -FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings."]
    pub fn fdt_add_subnode(
        fdt: *mut ::std::os::raw::c_void,
        parentoffset: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " fdt_del_node - delete a node (subtree)\n @fdt: pointer to the device tree blob\n @nodeoffset: offset of the node to nop\n\n fdt_del_node() will remove the given node, including all its\n subnodes if any, from the blob.\n\n This function will delete data from the blob, and will therefore\n change the offsets of some existing nodes.\n\n returns:\n\t0, on success\n\t-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag\n\t-FDT_ERR_BADLAYOUT,\n\t-FDT_ERR_BADMAGIC,\n\t-FDT_ERR_BADVERSION,\n\t-FDT_ERR_BADSTATE,\n\t-FDT_ERR_BADSTRUCTURE,\n\t-FDT_ERR_TRUNCATED, standard meanings"]
    pub fn fdt_del_node(
        fdt: *mut ::std::os::raw::c_void,
        nodeoffset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdt_strerror(errval: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
