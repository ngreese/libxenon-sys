/* automatically generated by rust-bindgen 0.72.1 */

pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const NO_SYS: u32 = 1;
pub const NO_SYS_NO_TIMERS: u32 = 1;
pub const ETHARP_TRUST_IP_MAC: u32 = 1;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const LWIP_TCP: u32 = 1;
pub const LWIP_UDP: u32 = 1;
pub const LWIP_DHCP: u32 = 1;
pub const LWIP_SOCKET: u32 = 0;
pub const LWIP_NETCONN: u32 = 0;
pub const LWIP_NETIF_HOSTNAME: u32 = 1;
pub const MEM_ALIGNMENT: u32 = 4;
pub const MEM_SIZE: u32 = 4194304;
pub const MEMP_NUM_PBUF: u32 = 1024;
pub const MEMP_NUM_UDP_PCB: u32 = 20;
pub const MEMP_NUM_TCP_PCB: u32 = 20;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 16;
pub const MEMP_NUM_TCP_SEG: u32 = 128;
pub const MEMP_NUM_NETBUF: u32 = 0;
pub const MEMP_NUM_NETCONN: u32 = 0;
pub const MEMP_NUM_SYS_TIMEOUT: u32 = 20;
pub const PBUF_POOL_SIZE: u32 = 512;
pub const TCP_TTL: u32 = 255;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const TCP_MSS: u32 = 1476;
pub const TCP_SND_BUF: u32 = 11808;
pub const TCP_WND: u32 = 5904;
pub const ARP_QUEUEING: u32 = 1;
pub const IP_FORWARD: u32 = 0;
pub const IP_OPTIONS: u32 = 1;
pub const DHCP_DOES_ARP_CHECK: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const U32_F: &[u8; 2] = b"u\0";
pub const U16_F: &[u8; 3] = b"hu\0";
pub const S32_F: &[u8; 2] = b"d\0";
pub const S16_F: &[u8; 3] = b"hd\0";
pub const X32_F: &[u8; 2] = b"x\0";
pub const X16_F: &[u8; 3] = b"hx\0";
pub const SZT_F: &[u8; 2] = b"u\0";
pub const X8_F: &[u8; 4] = b"02x\0";
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 0;
pub const MEM_LIBC_MALLOC: u32 = 0;
pub const MEMP_MEM_MALLOC: u32 = 0;
pub const MEMP_SEPARATE_POOLS: u32 = 0;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 0;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_RAW_PCB: u32 = 4;
pub const MEMP_NUM_REASSDATA: u32 = 5;
pub const MEMP_NUM_FRAG_PBUF: u32 = 15;
pub const MEMP_NUM_ARP_QUEUE: u32 = 30;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 8;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 8;
pub const MEMP_NUM_SNMP_NODE: u32 = 50;
pub const MEMP_NUM_SNMP_ROOTNODE: u32 = 30;
pub const MEMP_NUM_SNMP_VARBIND: u32 = 2;
pub const MEMP_NUM_SNMP_VALUE: u32 = 3;
pub const MEMP_NUM_NETDB: u32 = 1;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 1;
pub const MEMP_NUM_PPPOE_INTERFACES: u32 = 1;
pub const LWIP_ARP: u32 = 1;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_REASSEMBLY: u32 = 1;
pub const IP_FRAG: u32 = 1;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const IP_FRAG_USES_STATIC_BUF: u32 = 0;
pub const IP_DEFAULT_TTL: u32 = 255;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const LWIP_ICMP: u32 = 1;
pub const ICMP_TTL: u32 = 255;
pub const LWIP_BROADCAST_PING: u32 = 0;
pub const LWIP_MULTICAST_PING: u32 = 0;
pub const LWIP_RAW: u32 = 1;
pub const RAW_TTL: u32 = 255;
pub const LWIP_AUTOIP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_SNMP: u32 = 0;
pub const SNMP_CONCURRENT_REQUESTS: u32 = 1;
pub const SNMP_TRAP_DESTINATIONS: u32 = 1;
pub const SNMP_PRIVATE_MIB: u32 = 0;
pub const SNMP_SAFE_REQUESTS: u32 = 1;
pub const SNMP_MAX_OCTET_STRING_LEN: u32 = 127;
pub const SNMP_MAX_TREE_DEPTH: u32 = 15;
pub const LWIP_IGMP: u32 = 0;
pub const LWIP_DNS: u32 = 1;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_SERVERS: u32 = 2;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const DNS_MSG_SIZE: u32 = 512;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_UDPLITE: u32 = 0;
pub const UDP_TTL: u32 = 255;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const TCP_MAXRTX: u32 = 12;
pub const TCP_SYNMAXRTX: u32 = 6;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_SND_QUEUELEN: u32 = 32;
pub const TCP_SNDLOWAT: u32 = 5904;
pub const TCP_SNDQUEUELOWAT: u32 = 16;
pub const TCP_LISTEN_BACKLOG: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const TCP_OVERSIZE: u32 = 1476;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const TCP_WND_UPDATE_THRESHOLD: u32 = 1476;
pub const LWIP_EVENT_API: u32 = 0;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 1;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 1;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NETIF_LOOPBACK: u32 = 0;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 0;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 0;
pub const LWIP_HAVE_LOOPIF: u32 = 0;
pub const LWIP_HAVE_SLIPIF: u32 = 0;
pub const TCPIP_THREAD_NAME: &[u8; 13] = b"tcpip_thread\0";
pub const TCPIP_THREAD_STACKSIZE: u32 = 0;
pub const TCPIP_THREAD_PRIO: u32 = 1;
pub const TCPIP_MBOX_SIZE: u32 = 0;
pub const SLIPIF_THREAD_NAME: &[u8; 12] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const PPP_THREAD_NAME: &[u8; 15] = b"pppInputThread\0";
pub const PPP_THREAD_STACKSIZE: u32 = 0;
pub const PPP_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &[u8; 5] = b"lwIP\0";
pub const DEFAULT_THREAD_STACKSIZE: u32 = 0;
pub const DEFAULT_THREAD_PRIO: u32 = 1;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const LWIP_TCPIP_TIMEOUT: u32 = 1;
pub const LWIP_COMPAT_SOCKETS: u32 = 1;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 1;
pub const LWIP_TCP_KEEPALIVE: u32 = 0;
pub const LWIP_SO_RCVTIMEO: u32 = 0;
pub const LWIP_SO_RCVBUF: u32 = 0;
pub const SO_REUSE: u32 = 0;
pub const SO_REUSE_RXTOALL: u32 = 0;
pub const LWIP_STATS: u32 = 1;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const LINK_STATS: u32 = 1;
pub const ETHARP_STATS: u32 = 1;
pub const IP_STATS: u32 = 1;
pub const ICMP_STATS: u32 = 1;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 1;
pub const TCP_STATS: u32 = 1;
pub const PPP_SUPPORT: u32 = 0;
pub const PPPOE_SUPPORT: u32 = 0;
pub const PPPOS_SUPPORT: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_CHECK_IP: u32 = 1;
pub const CHECKSUM_CHECK_UDP: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const LWIP_DBG_MIN_LEVEL: u32 = 0;
pub const LWIP_DBG_TYPES_ON: u32 = 128;
pub const ETHARP_DEBUG: u32 = 0;
pub const NETIF_DEBUG: u32 = 0;
pub const PBUF_DEBUG: u32 = 0;
pub const API_LIB_DEBUG: u32 = 0;
pub const API_MSG_DEBUG: u32 = 0;
pub const SOCKETS_DEBUG: u32 = 0;
pub const ICMP_DEBUG: u32 = 0;
pub const IGMP_DEBUG: u32 = 0;
pub const INET_DEBUG: u32 = 0;
pub const IP_DEBUG: u32 = 0;
pub const IP_REASS_DEBUG: u32 = 0;
pub const RAW_DEBUG: u32 = 0;
pub const MEM_DEBUG: u32 = 0;
pub const MEMP_DEBUG: u32 = 0;
pub const SYS_DEBUG: u32 = 0;
pub const TIMERS_DEBUG: u32 = 0;
pub const TCP_DEBUG: u32 = 0;
pub const TCP_INPUT_DEBUG: u32 = 0;
pub const TCP_FR_DEBUG: u32 = 0;
pub const TCP_RTO_DEBUG: u32 = 0;
pub const TCP_CWND_DEBUG: u32 = 0;
pub const TCP_WND_DEBUG: u32 = 0;
pub const TCP_OUTPUT_DEBUG: u32 = 0;
pub const TCP_RST_DEBUG: u32 = 0;
pub const TCP_QLEN_DEBUG: u32 = 0;
pub const UDP_DEBUG: u32 = 0;
pub const TCPIP_DEBUG: u32 = 0;
pub const PPP_DEBUG: u32 = 0;
pub const SLIP_DEBUG: u32 = 0;
pub const DHCP_DEBUG: u32 = 0;
pub const AUTOIP_DEBUG: u32 = 0;
pub const SNMP_MSG_DEBUG: u32 = 0;
pub const SNMP_MIB_DEBUG: u32 = 0;
pub const DNS_DEBUG: u32 = 0;
pub const MEM_SIZE_F: &[u8; 2] = b"u\0";
pub const ERR_OK: u32 = 0;
pub const ERR_MEM: i32 = -1;
pub const ERR_BUF: i32 = -2;
pub const ERR_TIMEOUT: i32 = -3;
pub const ERR_RTE: i32 = -4;
pub const ERR_INPROGRESS: i32 = -5;
pub const ERR_VAL: i32 = -6;
pub const ERR_WOULDBLOCK: i32 = -7;
pub const ERR_USE: i32 = -8;
pub const ERR_ISCONN: i32 = -9;
pub const ERR_ABRT: i32 = -10;
pub const ERR_RST: i32 = -11;
pub const ERR_CLSD: i32 = -12;
pub const ERR_CONN: i32 = -13;
pub const ERR_ARG: i32 = -14;
pub const ERR_IF: i32 = -15;
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 20;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const LWIP_PLATFORM_BYTESWAP: u32 = 0;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const NETIF_MAX_HWADDR_LEN: u32 = 6;
pub const NETIF_FLAG_UP: u32 = 1;
pub const NETIF_FLAG_BROADCAST: u32 = 2;
pub const NETIF_FLAG_POINTTOPOINT: u32 = 4;
pub const NETIF_FLAG_DHCP: u32 = 8;
pub const NETIF_FLAG_LINK_UP: u32 = 16;
pub const NETIF_FLAG_ETHARP: u32 = 32;
pub const NETIF_FLAG_ETHERNET: u32 = 64;
pub const NETIF_FLAG_IGMP: u32 = 128;
pub const IP_OPTIONS_SEND: u32 = 0;
pub const IP_HLEN: u32 = 20;
pub const IP_PROTO_ICMP: u32 = 1;
pub const IP_PROTO_IGMP: u32 = 2;
pub const IP_PROTO_UDP: u32 = 17;
pub const IP_PROTO_UDPLITE: u32 = 136;
pub const IP_PROTO_TCP: u32 = 6;
pub const IP_RF: u32 = 32768;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_OFFMASK: u32 = 8191;
pub const ICMP_ER: u32 = 0;
pub const ICMP_DUR: u32 = 3;
pub const ICMP_SQ: u32 = 4;
pub const ICMP_RD: u32 = 5;
pub const ICMP_ECHO: u32 = 8;
pub const ICMP_TE: u32 = 11;
pub const ICMP_PP: u32 = 12;
pub const ICMP_TS: u32 = 13;
pub const ICMP_TSR: u32 = 14;
pub const ICMP_IRQ: u32 = 15;
pub const ICMP_IR: u32 = 16;
pub const TCP_SNDQUEUELEN_OVERFLOW: u32 = 65532;
pub const TCP_WRITE_FLAG_COPY: u32 = 1;
pub const TCP_WRITE_FLAG_MORE: u32 = 2;
pub const TCP_PRIO_MIN: u32 = 1;
pub const TCP_PRIO_NORMAL: u32 = 64;
pub const TCP_PRIO_MAX: u32 = 127;
pub const TCP_FIN: u32 = 1;
pub const TCP_SYN: u32 = 2;
pub const TCP_RST: u32 = 4;
pub const TCP_PSH: u32 = 8;
pub const TCP_ACK: u32 = 16;
pub const TCP_URG: u32 = 32;
pub const TCP_ECE: u32 = 64;
pub const TCP_CWR: u32 = 128;
pub const TCP_FLAGS: u32 = 63;
pub const TCP_HLEN: u32 = 20;
pub const TCP_TMR_INTERVAL: u32 = 250;
pub const TCP_FAST_INTERVAL: u32 = 250;
pub const TCP_SLOW_INTERVAL: u32 = 500;
pub const TCP_FIN_WAIT_TIMEOUT: u32 = 20000;
pub const TCP_SYN_RCVD_TIMEOUT: u32 = 20000;
pub const TCP_OOSEQ_TIMEOUT: u32 = 6;
pub const TCP_MSL: u32 = 60000;
pub const TCP_KEEPIDLE_DEFAULT: u32 = 7200000;
pub const TCP_KEEPINTVL_DEFAULT: u32 = 75000;
pub const TCP_KEEPCNT_DEFAULT: u32 = 9;
pub const TCP_MAXIDLE: u32 = 675000;
pub const TCP_OVERSIZE_DBGCHECK: u32 = 0;
pub const TCP_DEBUG_PCB_LISTS: u32 = 0;
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type u8_t = ::std::os::raw::c_uchar;
pub type s8_t = ::std::os::raw::c_schar;
pub type u16_t = ::std::os::raw::c_ushort;
pub type s16_t = ::std::os::raw::c_short;
pub type u32_t = ::std::os::raw::c_uint;
pub type s32_t = ::std::os::raw::c_int;
pub type u64_t = ::std::os::raw::c_ulong;
pub type s64_t = ::std::os::raw::c_long;
pub type mem_ptr_t = u64_t;
pub type sys_sem_t = u8_t;
pub type sys_mutex_t = u8_t;
pub type sys_mbox_t = u8_t;
unsafe extern "C" {
    pub fn sys_init();
}
unsafe extern "C" {
    #[doc = " Ticks/jiffies since power up."]
    pub fn sys_jiffies() -> u32_t;
}
unsafe extern "C" {
    #[doc = " Returns the current time in milliseconds,\n may be the same as sys_jiffies or at least based on it."]
    pub fn sys_now() -> u32_t;
}
pub type mem_size_t = u32_t;
unsafe extern "C" {
    pub fn mem_init();
}
unsafe extern "C" {
    pub fn mem_trim(
        mem: *mut ::std::os::raw::c_void,
        size: mem_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mem_malloc(size: mem_size_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mem_calloc(count: mem_size_t, size: mem_size_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mem_free(mem: *mut ::std::os::raw::c_void);
}
pub type err_t = s8_t;
pub const pbuf_layer_PBUF_TRANSPORT: pbuf_layer = 0;
pub const pbuf_layer_PBUF_IP: pbuf_layer = 1;
pub const pbuf_layer_PBUF_LINK: pbuf_layer = 2;
pub const pbuf_layer_PBUF_RAW: pbuf_layer = 3;
pub type pbuf_layer = ::std::os::raw::c_uint;
pub const pbuf_type_PBUF_RAM: pbuf_type = 0;
pub const pbuf_type_PBUF_ROM: pbuf_type = 1;
pub const pbuf_type_PBUF_REF: pbuf_type = 2;
pub const pbuf_type_PBUF_POOL: pbuf_type = 3;
pub type pbuf_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *mut ::std::os::raw::c_void,
    #[doc = " total length of this buffer and all next buffers in chain\n belonging to the same packet.\n\n For non-queue packet chains this is the invariant:\n p->tot_len == p->len + (p->next? p->next->tot_len: 0)"]
    pub tot_len: u16_t,
    #[doc = " length of this buffer"]
    pub len: u16_t,
    #[doc = " pbuf_type as u8_t instead of enum to save space"]
    pub type_: u8_t,
    #[doc = " misc flags"]
    pub flags: u8_t,
    #[doc = " the reference count always equals the number of pointers\n that refer to this pbuf. This can be pointers from an application,\n the stack itself, or pbuf->next pointers from a chain."]
    pub ref_: u16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pbuf"][::std::mem::size_of::<pbuf>() - 24usize];
    ["Alignment of pbuf"][::std::mem::align_of::<pbuf>() - 8usize];
    ["Offset of field: pbuf::next"][::std::mem::offset_of!(pbuf, next) - 0usize];
    ["Offset of field: pbuf::payload"][::std::mem::offset_of!(pbuf, payload) - 8usize];
    ["Offset of field: pbuf::tot_len"][::std::mem::offset_of!(pbuf, tot_len) - 16usize];
    ["Offset of field: pbuf::len"][::std::mem::offset_of!(pbuf, len) - 18usize];
    ["Offset of field: pbuf::type_"][::std::mem::offset_of!(pbuf, type_) - 20usize];
    ["Offset of field: pbuf::flags"][::std::mem::offset_of!(pbuf, flags) - 21usize];
    ["Offset of field: pbuf::ref_"][::std::mem::offset_of!(pbuf, ref_) - 22usize];
};
#[doc = " Prototype for a function to free a custom pbuf"]
pub type pbuf_free_custom_fn = ::std::option::Option<unsafe extern "C" fn(p: *mut pbuf)>;
#[doc = " A custom pbuf: like a pbuf, but following a function pointer to free it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf_custom {
    #[doc = " The actual pbuf"]
    pub pbuf: pbuf,
    #[doc = " This function is called when pbuf_free deallocates this pbuf(_custom)"]
    pub custom_free_function: pbuf_free_custom_fn,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pbuf_custom"][::std::mem::size_of::<pbuf_custom>() - 32usize];
    ["Alignment of pbuf_custom"][::std::mem::align_of::<pbuf_custom>() - 8usize];
    ["Offset of field: pbuf_custom::pbuf"][::std::mem::offset_of!(pbuf_custom, pbuf) - 0usize];
    ["Offset of field: pbuf_custom::custom_free_function"]
        [::std::mem::offset_of!(pbuf_custom, custom_free_function) - 24usize];
};
unsafe extern "C" {
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
}
unsafe extern "C" {
    pub fn pbuf_alloced_custom(
        l: pbuf_layer,
        length: u16_t,
        type_: pbuf_type,
        p: *mut pbuf_custom,
        payload_mem: *mut ::std::os::raw::c_void,
        payload_mem_len: u16_t,
    ) -> *mut pbuf;
}
unsafe extern "C" {
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
}
unsafe extern "C" {
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
unsafe extern "C" {
    pub fn pbuf_ref(p: *mut pbuf);
}
unsafe extern "C" {
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
}
unsafe extern "C" {
    pub fn pbuf_clen(p: *mut pbuf) -> u8_t;
}
unsafe extern "C" {
    pub fn pbuf_cat(head: *mut pbuf, tail: *mut pbuf);
}
unsafe extern "C" {
    pub fn pbuf_chain(head: *mut pbuf, tail: *mut pbuf);
}
unsafe extern "C" {
    pub fn pbuf_dechain(p: *mut pbuf) -> *mut pbuf;
}
unsafe extern "C" {
    pub fn pbuf_copy(p_to: *mut pbuf, p_from: *mut pbuf) -> err_t;
}
unsafe extern "C" {
    pub fn pbuf_copy_partial(
        p: *mut pbuf,
        dataptr: *mut ::std::os::raw::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> u16_t;
}
unsafe extern "C" {
    pub fn pbuf_take(buf: *mut pbuf, dataptr: *const ::std::os::raw::c_void, len: u16_t) -> err_t;
}
unsafe extern "C" {
    pub fn pbuf_coalesce(p: *mut pbuf, layer: pbuf_layer) -> *mut pbuf;
}
unsafe extern "C" {
    pub fn pbuf_get_at(p: *mut pbuf, offset: u16_t) -> u8_t;
}
unsafe extern "C" {
    pub fn pbuf_memcmp(
        p: *mut pbuf,
        offset: u16_t,
        s2: *const ::std::os::raw::c_void,
        n: u16_t,
    ) -> u16_t;
}
unsafe extern "C" {
    pub fn pbuf_memfind(
        p: *mut pbuf,
        mem: *const ::std::os::raw::c_void,
        mem_len: u16_t,
        start_offset: u16_t,
    ) -> u16_t;
}
unsafe extern "C" {
    pub fn pbuf_strstr(p: *mut pbuf, substr: *const ::std::os::raw::c_char) -> u16_t;
}
unsafe extern "C" {
    pub fn lwip_htons(x: u16_t) -> u16_t;
}
unsafe extern "C" {
    pub fn lwip_ntohs(x: u16_t) -> u16_t;
}
unsafe extern "C" {
    pub fn lwip_htonl(x: u32_t) -> u32_t;
}
unsafe extern "C" {
    pub fn lwip_ntohl(x: u32_t) -> u32_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr {
    pub addr: u32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_addr"][::std::mem::size_of::<ip_addr>() - 4usize];
    ["Alignment of ip_addr"][::std::mem::align_of::<ip_addr>() - 4usize];
    ["Offset of field: ip_addr::addr"][::std::mem::offset_of!(ip_addr, addr) - 0usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr_packed {
    pub addr: u32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_addr_packed"][::std::mem::size_of::<ip_addr_packed>() - 4usize];
    ["Alignment of ip_addr_packed"][::std::mem::align_of::<ip_addr_packed>() - 1usize];
    ["Offset of field: ip_addr_packed::addr"]
        [::std::mem::offset_of!(ip_addr_packed, addr) - 0usize];
};
#[doc = " ip_addr_t uses a struct for convenience only, so that the same defines can\n operate both on ip_addr_t as well as on ip_addr_p_t."]
pub type ip_addr_t = ip_addr;
pub type ip_addr_p_t = ip_addr_packed;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_addr2 {
    pub addrw: [u16_t; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_addr2"][::std::mem::size_of::<ip_addr2>() - 4usize];
    ["Alignment of ip_addr2"][::std::mem::align_of::<ip_addr2>() - 1usize];
    ["Offset of field: ip_addr2::addrw"][::std::mem::offset_of!(ip_addr2, addrw) - 0usize];
};
unsafe extern "C" {
    pub static ip_addr_any: ip_addr_t;
}
unsafe extern "C" {
    pub static ip_addr_broadcast: ip_addr_t;
}
unsafe extern "C" {
    pub fn ip4_addr_isbroadcast(addr: u32_t, netif: *const netif) -> u8_t;
}
unsafe extern "C" {
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
}
unsafe extern "C" {
    pub fn ipaddr_addr(cp: *const ::std::os::raw::c_char) -> u32_t;
}
unsafe extern "C" {
    pub fn ipaddr_aton(
        cp: *const ::std::os::raw::c_char,
        addr: *mut ip_addr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ipaddr_ntoa(addr: *const ip_addr_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ipaddr_ntoa_r(
        addr: *const ip_addr_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcp {
    _unused: [u8; 0],
}
#[doc = " Function prototype for netif init functions. Set up flags and output/linkoutput\n callback functions in this function.\n\n @param netif The netif to initialize"]
pub type netif_init_fn = ::std::option::Option<unsafe extern "C" fn(netif: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->input functions. This function is saved as 'input'\n callback function in the netif struct. Call it when a packet has been received.\n\n @param p The received packet, copied into a pbuf\n @param inp The netif which received the packet"]
pub type netif_input_fn =
    ::std::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->output functions. Called by lwIP when a packet\n shall be sent. For ethernet netif, set this to 'etharp_output' and set\n 'linkoutput'.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (p->payload points to IP header)\n @param ipaddr The IP address to which the packet shall be sent"]
pub type netif_output_fn = ::std::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *mut ip_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->linkoutput functions. Only used for ethernet\n netifs. This function is called by ARP when a packet shall be sent.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (raw ethernet packet)"]
pub type netif_linkoutput_fn =
    ::std::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
#[doc = " Function prototype for netif status- or link-callback functions."]
pub type netif_status_callback_fn = ::std::option::Option<unsafe extern "C" fn(netif: *mut netif)>;
#[doc = " Function prototype for netif igmp_mac_filter functions"]
pub type netif_igmp_mac_filter_fn = ::std::option::Option<
    unsafe extern "C" fn(netif: *mut netif, group: *mut ip_addr_t, action: u8_t) -> err_t,
>;
#[doc = " Generic data structure used for all lwIP network interfaces.\n  The following fields should be filled in by the initialization\n  function for the device driver: hwaddr_len, hwaddr[], mtu, flags"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif {
    #[doc = " pointer to next in linked list"]
    pub next: *mut netif,
    #[doc = " IP address configuration in network byte order"]
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    #[doc = " This function is called by the network device driver\n  to pass a packet up the TCP/IP stack."]
    pub input: netif_input_fn,
    #[doc = " This function is called by the IP module when it wants\n  to send a packet on the interface. This function typically\n  first resolves the hardware address, then sends the packet."]
    pub output: netif_output_fn,
    #[doc = " This function is called by the ARP module when it wants\n  to send a packet on the interface. This function outputs\n  the pbuf as-is on the link medium."]
    pub linkoutput: netif_linkoutput_fn,
    #[doc = " This function is called when the netif state is set to up or down"]
    pub status_callback: netif_status_callback_fn,
    #[doc = " This function is called when the netif link is set to up or down"]
    pub link_callback: netif_status_callback_fn,
    #[doc = " This field can be set by the device driver and could point\n  to state information for the device."]
    pub state: *mut ::std::os::raw::c_void,
    #[doc = " the DHCP client state information for this netif"]
    pub dhcp: *mut dhcp,
    pub hostname: *mut ::std::os::raw::c_char,
    #[doc = " maximum transfer unit (in bytes)"]
    pub mtu: u16_t,
    #[doc = " number of bytes used in hwaddr"]
    pub hwaddr_len: u8_t,
    #[doc = " link level hardware address of this interface"]
    pub hwaddr: [u8_t; 6usize],
    #[doc = " flags (see NETIF_FLAG_ above)"]
    pub flags: u8_t,
    #[doc = " descriptive abbreviation"]
    pub name: [::std::os::raw::c_char; 2usize],
    #[doc = " number of this interface"]
    pub num: u8_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of netif"][::std::mem::size_of::<netif>() - 104usize];
    ["Alignment of netif"][::std::mem::align_of::<netif>() - 8usize];
    ["Offset of field: netif::next"][::std::mem::offset_of!(netif, next) - 0usize];
    ["Offset of field: netif::ip_addr"][::std::mem::offset_of!(netif, ip_addr) - 8usize];
    ["Offset of field: netif::netmask"][::std::mem::offset_of!(netif, netmask) - 12usize];
    ["Offset of field: netif::gw"][::std::mem::offset_of!(netif, gw) - 16usize];
    ["Offset of field: netif::input"][::std::mem::offset_of!(netif, input) - 24usize];
    ["Offset of field: netif::output"][::std::mem::offset_of!(netif, output) - 32usize];
    ["Offset of field: netif::linkoutput"][::std::mem::offset_of!(netif, linkoutput) - 40usize];
    ["Offset of field: netif::status_callback"]
        [::std::mem::offset_of!(netif, status_callback) - 48usize];
    ["Offset of field: netif::link_callback"]
        [::std::mem::offset_of!(netif, link_callback) - 56usize];
    ["Offset of field: netif::state"][::std::mem::offset_of!(netif, state) - 64usize];
    ["Offset of field: netif::dhcp"][::std::mem::offset_of!(netif, dhcp) - 72usize];
    ["Offset of field: netif::hostname"][::std::mem::offset_of!(netif, hostname) - 80usize];
    ["Offset of field: netif::mtu"][::std::mem::offset_of!(netif, mtu) - 88usize];
    ["Offset of field: netif::hwaddr_len"][::std::mem::offset_of!(netif, hwaddr_len) - 90usize];
    ["Offset of field: netif::hwaddr"][::std::mem::offset_of!(netif, hwaddr) - 91usize];
    ["Offset of field: netif::flags"][::std::mem::offset_of!(netif, flags) - 97usize];
    ["Offset of field: netif::name"][::std::mem::offset_of!(netif, name) - 98usize];
    ["Offset of field: netif::num"][::std::mem::offset_of!(netif, num) - 100usize];
};
unsafe extern "C" {
    #[doc = " The list of network interfaces."]
    pub static mut netif_list: *mut netif;
}
unsafe extern "C" {
    #[doc = " The default network interface."]
    pub static mut netif_default: *mut netif;
}
unsafe extern "C" {
    pub fn netif_init();
}
unsafe extern "C" {
    pub fn netif_add(
        netif: *mut netif,
        ipaddr: *mut ip_addr_t,
        netmask: *mut ip_addr_t,
        gw: *mut ip_addr_t,
        state: *mut ::std::os::raw::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
}
unsafe extern "C" {
    pub fn netif_set_addr(
        netif: *mut netif,
        ipaddr: *mut ip_addr_t,
        netmask: *mut ip_addr_t,
        gw: *mut ip_addr_t,
    );
}
unsafe extern "C" {
    pub fn netif_remove(netif: *mut netif);
}
unsafe extern "C" {
    pub fn netif_find(name: *mut ::std::os::raw::c_char) -> *mut netif;
}
unsafe extern "C" {
    pub fn netif_set_default(netif: *mut netif);
}
unsafe extern "C" {
    pub fn netif_set_ipaddr(netif: *mut netif, ipaddr: *mut ip_addr_t);
}
unsafe extern "C" {
    pub fn netif_set_netmask(netif: *mut netif, netmask: *mut ip_addr_t);
}
unsafe extern "C" {
    pub fn netif_set_gw(netif: *mut netif, gw: *mut ip_addr_t);
}
unsafe extern "C" {
    pub fn netif_set_up(netif: *mut netif);
}
unsafe extern "C" {
    pub fn netif_set_down(netif: *mut netif);
}
unsafe extern "C" {
    pub fn netif_set_status_callback(netif: *mut netif, status_callback: netif_status_callback_fn);
}
unsafe extern "C" {
    pub fn netif_set_link_up(netif: *mut netif);
}
unsafe extern "C" {
    pub fn netif_set_link_down(netif: *mut netif);
}
unsafe extern "C" {
    pub fn netif_set_link_callback(netif: *mut netif, link_callback: netif_status_callback_fn);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_pcb {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_pcb"][::std::mem::size_of::<ip_pcb>() - 12usize];
    ["Alignment of ip_pcb"][::std::mem::align_of::<ip_pcb>() - 4usize];
    ["Offset of field: ip_pcb::local_ip"][::std::mem::offset_of!(ip_pcb, local_ip) - 0usize];
    ["Offset of field: ip_pcb::remote_ip"][::std::mem::offset_of!(ip_pcb, remote_ip) - 4usize];
    ["Offset of field: ip_pcb::so_options"][::std::mem::offset_of!(ip_pcb, so_options) - 8usize];
    ["Offset of field: ip_pcb::tos"][::std::mem::offset_of!(ip_pcb, tos) - 9usize];
    ["Offset of field: ip_pcb::ttl"][::std::mem::offset_of!(ip_pcb, ttl) - 10usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip_hdr {
    pub _v_hl_tos: u16_t,
    pub _len: u16_t,
    pub _id: u16_t,
    pub _offset: u16_t,
    pub _ttl: u8_t,
    pub _proto: u8_t,
    pub _chksum: u16_t,
    pub src: ip_addr_p_t,
    pub dest: ip_addr_p_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_hdr"][::std::mem::size_of::<ip_hdr>() - 20usize];
    ["Alignment of ip_hdr"][::std::mem::align_of::<ip_hdr>() - 1usize];
    ["Offset of field: ip_hdr::_v_hl_tos"][::std::mem::offset_of!(ip_hdr, _v_hl_tos) - 0usize];
    ["Offset of field: ip_hdr::_len"][::std::mem::offset_of!(ip_hdr, _len) - 2usize];
    ["Offset of field: ip_hdr::_id"][::std::mem::offset_of!(ip_hdr, _id) - 4usize];
    ["Offset of field: ip_hdr::_offset"][::std::mem::offset_of!(ip_hdr, _offset) - 6usize];
    ["Offset of field: ip_hdr::_ttl"][::std::mem::offset_of!(ip_hdr, _ttl) - 8usize];
    ["Offset of field: ip_hdr::_proto"][::std::mem::offset_of!(ip_hdr, _proto) - 9usize];
    ["Offset of field: ip_hdr::_chksum"][::std::mem::offset_of!(ip_hdr, _chksum) - 10usize];
    ["Offset of field: ip_hdr::src"][::std::mem::offset_of!(ip_hdr, src) - 12usize];
    ["Offset of field: ip_hdr::dest"][::std::mem::offset_of!(ip_hdr, dest) - 16usize];
};
unsafe extern "C" {
    #[doc = " The interface that provided the packet for the current callback invocation."]
    pub static mut current_netif: *mut netif;
}
unsafe extern "C" {
    #[doc = " Header of the input packet currently being processed."]
    pub static mut current_header: *const ip_hdr;
}
unsafe extern "C" {
    #[doc = " Source IP address of current_header"]
    pub static mut current_iphdr_src: ip_addr_t;
}
unsafe extern "C" {
    #[doc = " Destination IP address of current_header"]
    pub static mut current_iphdr_dest: ip_addr_t;
}
unsafe extern "C" {
    pub fn ip_route(dest: *mut ip_addr_t) -> *mut netif;
}
unsafe extern "C" {
    pub fn ip_input(p: *mut pbuf, inp: *mut netif) -> err_t;
}
unsafe extern "C" {
    pub fn ip_output(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
    ) -> err_t;
}
unsafe extern "C" {
    pub fn ip_output_if(
        p: *mut pbuf,
        src: *mut ip_addr_t,
        dest: *mut ip_addr_t,
        ttl: u8_t,
        tos: u8_t,
        proto: u8_t,
        netif: *mut netif,
    ) -> err_t;
}
pub const icmp_dur_type_ICMP_DUR_NET: icmp_dur_type = 0;
pub const icmp_dur_type_ICMP_DUR_HOST: icmp_dur_type = 1;
pub const icmp_dur_type_ICMP_DUR_PROTO: icmp_dur_type = 2;
pub const icmp_dur_type_ICMP_DUR_PORT: icmp_dur_type = 3;
pub const icmp_dur_type_ICMP_DUR_FRAG: icmp_dur_type = 4;
pub const icmp_dur_type_ICMP_DUR_SR: icmp_dur_type = 5;
pub type icmp_dur_type = ::std::os::raw::c_uint;
pub const icmp_te_type_ICMP_TE_TTL: icmp_te_type = 0;
pub const icmp_te_type_ICMP_TE_FRAG: icmp_te_type = 1;
pub type icmp_te_type = ::std::os::raw::c_uint;
#[doc = " This is the standard ICMP header only that the u32_t data\n  is splitted to two u16_t like ICMP echo needs it.\n  This header is also used for other ICMP types that do not\n  use the data part."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct icmp_echo_hdr {
    pub type_: u8_t,
    pub code: u8_t,
    pub chksum: u16_t,
    pub id: u16_t,
    pub seqno: u16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of icmp_echo_hdr"][::std::mem::size_of::<icmp_echo_hdr>() - 8usize];
    ["Alignment of icmp_echo_hdr"][::std::mem::align_of::<icmp_echo_hdr>() - 1usize];
    ["Offset of field: icmp_echo_hdr::type_"]
        [::std::mem::offset_of!(icmp_echo_hdr, type_) - 0usize];
    ["Offset of field: icmp_echo_hdr::code"][::std::mem::offset_of!(icmp_echo_hdr, code) - 1usize];
    ["Offset of field: icmp_echo_hdr::chksum"]
        [::std::mem::offset_of!(icmp_echo_hdr, chksum) - 2usize];
    ["Offset of field: icmp_echo_hdr::id"][::std::mem::offset_of!(icmp_echo_hdr, id) - 4usize];
    ["Offset of field: icmp_echo_hdr::seqno"]
        [::std::mem::offset_of!(icmp_echo_hdr, seqno) - 6usize];
};
unsafe extern "C" {
    pub fn icmp_input(p: *mut pbuf, inp: *mut netif);
}
unsafe extern "C" {
    pub fn icmp_dest_unreach(p: *mut pbuf, t: icmp_dur_type);
}
unsafe extern "C" {
    pub fn icmp_time_exceeded(p: *mut pbuf, t: icmp_te_type);
}
#[doc = " Function prototype for tcp accept callback functions. Called when a new\n connection can be accepted on a listening pcb.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param newpcb The new connection pcb\n @param err An error code if there has been an error accepting.\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_accept_fn = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        newpcb: *mut tcp_pcb,
        err: err_t,
    ) -> err_t,
>;
#[doc = " Function prototype for tcp receive callback functions. Called when data has\n been received.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb which received data\n @param p The received data (or NULL when the connection has been closed!)\n @param err An error code if there has been an error receiving\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_recv_fn = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        tpcb: *mut tcp_pcb,
        p: *mut pbuf,
        err: err_t,
    ) -> err_t,
>;
#[doc = " Function prototype for tcp sent callback functions. Called when sent data has\n been acknowledged by the remote side. Use it to free corresponding resources.\n This also means that the pcb has now space available to send new data.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb for which data has been acknowledged\n @param len The amount of bytes acknowledged\n @return ERR_OK: try to send some data by calling tcp_output\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_sent_fn = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, tpcb: *mut tcp_pcb, len: u16_t) -> err_t,
>;
#[doc = " Function prototype for tcp poll callback functions. Called periodically as\n specified by @see tcp_poll.\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb tcp pcb\n @return ERR_OK: try to send some data by calling tcp_output\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!"]
pub type tcp_poll_fn = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, tpcb: *mut tcp_pcb) -> err_t,
>;
#[doc = " Function prototype for tcp error callback functions. Called when the pcb\n receives a RST or is unexpectedly closed for any other reason.\n\n @note The corresponding pcb is already freed when this callback is called!\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param err Error code to indicate why the pcb has been closed\n            ERR_ABRT: aborted through tcp_abort or by a TCP timer\n            ERR_RST: the connection was reset by the remote host"]
pub type tcp_err_fn =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, err: err_t)>;
#[doc = " Function prototype for tcp connected callback functions. Called when a pcb\n is connected to the remote side after initiating a connection attempt by\n calling tcp_connect().\n\n @param arg Additional argument to pass to the callback function (@see tcp_arg())\n @param tpcb The connection pcb which is connected\n @param err An unused error code, always ERR_OK currently ;-) TODO!\n            Only return ERR_ABRT if you have called tcp_abort from within the\n            callback function!\n\n @note When a connection attempt fails, the error callback is currently called!"]
pub type tcp_connected_fn = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, tpcb: *mut tcp_pcb, err: err_t) -> err_t,
>;
pub const tcp_state_CLOSED: tcp_state = 0;
pub const tcp_state_LISTEN: tcp_state = 1;
pub const tcp_state_SYN_SENT: tcp_state = 2;
pub const tcp_state_SYN_RCVD: tcp_state = 3;
pub const tcp_state_ESTABLISHED: tcp_state = 4;
pub const tcp_state_FIN_WAIT_1: tcp_state = 5;
pub const tcp_state_FIN_WAIT_2: tcp_state = 6;
pub const tcp_state_CLOSE_WAIT: tcp_state = 7;
pub const tcp_state_CLOSING: tcp_state = 8;
pub const tcp_state_LAST_ACK: tcp_state = 9;
pub const tcp_state_TIME_WAIT: tcp_state = 10;
pub type tcp_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_pcb {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
    pub next: *mut tcp_pcb,
    pub state: tcp_state,
    pub prio: u8_t,
    pub callback_arg: *mut ::std::os::raw::c_void,
    pub accept: tcp_accept_fn,
    pub local_port: u16_t,
    pub remote_port: u16_t,
    pub flags: u8_t,
    pub rcv_nxt: u32_t,
    pub rcv_wnd: u16_t,
    pub rcv_ann_wnd: u16_t,
    pub rcv_ann_right_edge: u32_t,
    pub tmr: u32_t,
    pub polltmr: u8_t,
    pub pollinterval: u8_t,
    pub rtime: s16_t,
    pub mss: u16_t,
    pub rttest: u32_t,
    pub rtseq: u32_t,
    pub sa: s16_t,
    pub sv: s16_t,
    pub rto: s16_t,
    pub nrtx: u8_t,
    pub lastack: u32_t,
    pub dupacks: u8_t,
    pub cwnd: u16_t,
    pub ssthresh: u16_t,
    pub snd_nxt: u32_t,
    pub snd_wnd: u16_t,
    pub snd_wl1: u32_t,
    pub snd_wl2: u32_t,
    pub snd_lbb: u32_t,
    pub acked: u16_t,
    pub snd_buf: u16_t,
    pub snd_queuelen: u16_t,
    pub unsent_oversize: u16_t,
    pub unsent: *mut tcp_seg,
    pub unacked: *mut tcp_seg,
    pub ooseq: *mut tcp_seg,
    pub refused_data: *mut pbuf,
    pub sent: tcp_sent_fn,
    pub recv: tcp_recv_fn,
    pub connected: tcp_connected_fn,
    pub poll: tcp_poll_fn,
    pub errf: tcp_err_fn,
    pub keep_idle: u32_t,
    pub persist_cnt: u32_t,
    pub persist_backoff: u8_t,
    pub keep_cnt_sent: u8_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_pcb"][::std::mem::size_of::<tcp_pcb>() - 224usize];
    ["Alignment of tcp_pcb"][::std::mem::align_of::<tcp_pcb>() - 8usize];
    ["Offset of field: tcp_pcb::local_ip"][::std::mem::offset_of!(tcp_pcb, local_ip) - 0usize];
    ["Offset of field: tcp_pcb::remote_ip"][::std::mem::offset_of!(tcp_pcb, remote_ip) - 4usize];
    ["Offset of field: tcp_pcb::so_options"][::std::mem::offset_of!(tcp_pcb, so_options) - 8usize];
    ["Offset of field: tcp_pcb::tos"][::std::mem::offset_of!(tcp_pcb, tos) - 9usize];
    ["Offset of field: tcp_pcb::ttl"][::std::mem::offset_of!(tcp_pcb, ttl) - 10usize];
    ["Offset of field: tcp_pcb::next"][::std::mem::offset_of!(tcp_pcb, next) - 16usize];
    ["Offset of field: tcp_pcb::state"][::std::mem::offset_of!(tcp_pcb, state) - 24usize];
    ["Offset of field: tcp_pcb::prio"][::std::mem::offset_of!(tcp_pcb, prio) - 28usize];
    ["Offset of field: tcp_pcb::callback_arg"]
        [::std::mem::offset_of!(tcp_pcb, callback_arg) - 32usize];
    ["Offset of field: tcp_pcb::accept"][::std::mem::offset_of!(tcp_pcb, accept) - 40usize];
    ["Offset of field: tcp_pcb::local_port"][::std::mem::offset_of!(tcp_pcb, local_port) - 48usize];
    ["Offset of field: tcp_pcb::remote_port"]
        [::std::mem::offset_of!(tcp_pcb, remote_port) - 50usize];
    ["Offset of field: tcp_pcb::flags"][::std::mem::offset_of!(tcp_pcb, flags) - 52usize];
    ["Offset of field: tcp_pcb::rcv_nxt"][::std::mem::offset_of!(tcp_pcb, rcv_nxt) - 56usize];
    ["Offset of field: tcp_pcb::rcv_wnd"][::std::mem::offset_of!(tcp_pcb, rcv_wnd) - 60usize];
    ["Offset of field: tcp_pcb::rcv_ann_wnd"]
        [::std::mem::offset_of!(tcp_pcb, rcv_ann_wnd) - 62usize];
    ["Offset of field: tcp_pcb::rcv_ann_right_edge"]
        [::std::mem::offset_of!(tcp_pcb, rcv_ann_right_edge) - 64usize];
    ["Offset of field: tcp_pcb::tmr"][::std::mem::offset_of!(tcp_pcb, tmr) - 68usize];
    ["Offset of field: tcp_pcb::polltmr"][::std::mem::offset_of!(tcp_pcb, polltmr) - 72usize];
    ["Offset of field: tcp_pcb::pollinterval"]
        [::std::mem::offset_of!(tcp_pcb, pollinterval) - 73usize];
    ["Offset of field: tcp_pcb::rtime"][::std::mem::offset_of!(tcp_pcb, rtime) - 74usize];
    ["Offset of field: tcp_pcb::mss"][::std::mem::offset_of!(tcp_pcb, mss) - 76usize];
    ["Offset of field: tcp_pcb::rttest"][::std::mem::offset_of!(tcp_pcb, rttest) - 80usize];
    ["Offset of field: tcp_pcb::rtseq"][::std::mem::offset_of!(tcp_pcb, rtseq) - 84usize];
    ["Offset of field: tcp_pcb::sa"][::std::mem::offset_of!(tcp_pcb, sa) - 88usize];
    ["Offset of field: tcp_pcb::sv"][::std::mem::offset_of!(tcp_pcb, sv) - 90usize];
    ["Offset of field: tcp_pcb::rto"][::std::mem::offset_of!(tcp_pcb, rto) - 92usize];
    ["Offset of field: tcp_pcb::nrtx"][::std::mem::offset_of!(tcp_pcb, nrtx) - 94usize];
    ["Offset of field: tcp_pcb::lastack"][::std::mem::offset_of!(tcp_pcb, lastack) - 96usize];
    ["Offset of field: tcp_pcb::dupacks"][::std::mem::offset_of!(tcp_pcb, dupacks) - 100usize];
    ["Offset of field: tcp_pcb::cwnd"][::std::mem::offset_of!(tcp_pcb, cwnd) - 102usize];
    ["Offset of field: tcp_pcb::ssthresh"][::std::mem::offset_of!(tcp_pcb, ssthresh) - 104usize];
    ["Offset of field: tcp_pcb::snd_nxt"][::std::mem::offset_of!(tcp_pcb, snd_nxt) - 108usize];
    ["Offset of field: tcp_pcb::snd_wnd"][::std::mem::offset_of!(tcp_pcb, snd_wnd) - 112usize];
    ["Offset of field: tcp_pcb::snd_wl1"][::std::mem::offset_of!(tcp_pcb, snd_wl1) - 116usize];
    ["Offset of field: tcp_pcb::snd_wl2"][::std::mem::offset_of!(tcp_pcb, snd_wl2) - 120usize];
    ["Offset of field: tcp_pcb::snd_lbb"][::std::mem::offset_of!(tcp_pcb, snd_lbb) - 124usize];
    ["Offset of field: tcp_pcb::acked"][::std::mem::offset_of!(tcp_pcb, acked) - 128usize];
    ["Offset of field: tcp_pcb::snd_buf"][::std::mem::offset_of!(tcp_pcb, snd_buf) - 130usize];
    ["Offset of field: tcp_pcb::snd_queuelen"]
        [::std::mem::offset_of!(tcp_pcb, snd_queuelen) - 132usize];
    ["Offset of field: tcp_pcb::unsent_oversize"]
        [::std::mem::offset_of!(tcp_pcb, unsent_oversize) - 134usize];
    ["Offset of field: tcp_pcb::unsent"][::std::mem::offset_of!(tcp_pcb, unsent) - 136usize];
    ["Offset of field: tcp_pcb::unacked"][::std::mem::offset_of!(tcp_pcb, unacked) - 144usize];
    ["Offset of field: tcp_pcb::ooseq"][::std::mem::offset_of!(tcp_pcb, ooseq) - 152usize];
    ["Offset of field: tcp_pcb::refused_data"]
        [::std::mem::offset_of!(tcp_pcb, refused_data) - 160usize];
    ["Offset of field: tcp_pcb::sent"][::std::mem::offset_of!(tcp_pcb, sent) - 168usize];
    ["Offset of field: tcp_pcb::recv"][::std::mem::offset_of!(tcp_pcb, recv) - 176usize];
    ["Offset of field: tcp_pcb::connected"][::std::mem::offset_of!(tcp_pcb, connected) - 184usize];
    ["Offset of field: tcp_pcb::poll"][::std::mem::offset_of!(tcp_pcb, poll) - 192usize];
    ["Offset of field: tcp_pcb::errf"][::std::mem::offset_of!(tcp_pcb, errf) - 200usize];
    ["Offset of field: tcp_pcb::keep_idle"][::std::mem::offset_of!(tcp_pcb, keep_idle) - 208usize];
    ["Offset of field: tcp_pcb::persist_cnt"]
        [::std::mem::offset_of!(tcp_pcb, persist_cnt) - 212usize];
    ["Offset of field: tcp_pcb::persist_backoff"]
        [::std::mem::offset_of!(tcp_pcb, persist_backoff) - 216usize];
    ["Offset of field: tcp_pcb::keep_cnt_sent"]
        [::std::mem::offset_of!(tcp_pcb, keep_cnt_sent) - 217usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_pcb_listen {
    pub local_ip: ip_addr_t,
    pub remote_ip: ip_addr_t,
    pub so_options: u8_t,
    pub tos: u8_t,
    pub ttl: u8_t,
    pub next: *mut tcp_pcb_listen,
    pub state: tcp_state,
    pub prio: u8_t,
    pub callback_arg: *mut ::std::os::raw::c_void,
    pub accept: tcp_accept_fn,
    pub local_port: u16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_pcb_listen"][::std::mem::size_of::<tcp_pcb_listen>() - 56usize];
    ["Alignment of tcp_pcb_listen"][::std::mem::align_of::<tcp_pcb_listen>() - 8usize];
    ["Offset of field: tcp_pcb_listen::local_ip"]
        [::std::mem::offset_of!(tcp_pcb_listen, local_ip) - 0usize];
    ["Offset of field: tcp_pcb_listen::remote_ip"]
        [::std::mem::offset_of!(tcp_pcb_listen, remote_ip) - 4usize];
    ["Offset of field: tcp_pcb_listen::so_options"]
        [::std::mem::offset_of!(tcp_pcb_listen, so_options) - 8usize];
    ["Offset of field: tcp_pcb_listen::tos"][::std::mem::offset_of!(tcp_pcb_listen, tos) - 9usize];
    ["Offset of field: tcp_pcb_listen::ttl"][::std::mem::offset_of!(tcp_pcb_listen, ttl) - 10usize];
    ["Offset of field: tcp_pcb_listen::next"]
        [::std::mem::offset_of!(tcp_pcb_listen, next) - 16usize];
    ["Offset of field: tcp_pcb_listen::state"]
        [::std::mem::offset_of!(tcp_pcb_listen, state) - 24usize];
    ["Offset of field: tcp_pcb_listen::prio"]
        [::std::mem::offset_of!(tcp_pcb_listen, prio) - 28usize];
    ["Offset of field: tcp_pcb_listen::callback_arg"]
        [::std::mem::offset_of!(tcp_pcb_listen, callback_arg) - 32usize];
    ["Offset of field: tcp_pcb_listen::accept"]
        [::std::mem::offset_of!(tcp_pcb_listen, accept) - 40usize];
    ["Offset of field: tcp_pcb_listen::local_port"]
        [::std::mem::offset_of!(tcp_pcb_listen, local_port) - 48usize];
};
unsafe extern "C" {
    pub fn tcp_new() -> *mut tcp_pcb;
}
unsafe extern "C" {
    pub fn tcp_arg(pcb: *mut tcp_pcb, arg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn tcp_accept(pcb: *mut tcp_pcb, accept: tcp_accept_fn);
}
unsafe extern "C" {
    pub fn tcp_recv(pcb: *mut tcp_pcb, recv: tcp_recv_fn);
}
unsafe extern "C" {
    pub fn tcp_sent(pcb: *mut tcp_pcb, sent: tcp_sent_fn);
}
unsafe extern "C" {
    pub fn tcp_poll(pcb: *mut tcp_pcb, poll: tcp_poll_fn, interval: u8_t);
}
unsafe extern "C" {
    pub fn tcp_err(pcb: *mut tcp_pcb, err: tcp_err_fn);
}
unsafe extern "C" {
    pub fn tcp_recved(pcb: *mut tcp_pcb, len: u16_t);
}
unsafe extern "C" {
    pub fn tcp_bind(pcb: *mut tcp_pcb, ipaddr: *mut ip_addr_t, port: u16_t) -> err_t;
}
unsafe extern "C" {
    pub fn tcp_connect(
        pcb: *mut tcp_pcb,
        ipaddr: *mut ip_addr_t,
        port: u16_t,
        connected: tcp_connected_fn,
    ) -> err_t;
}
unsafe extern "C" {
    pub fn tcp_listen_with_backlog(pcb: *mut tcp_pcb, backlog: u8_t) -> *mut tcp_pcb;
}
unsafe extern "C" {
    pub fn tcp_abort(pcb: *mut tcp_pcb);
}
unsafe extern "C" {
    pub fn tcp_close(pcb: *mut tcp_pcb) -> err_t;
}
unsafe extern "C" {
    pub fn tcp_shutdown(
        pcb: *mut tcp_pcb,
        shut_rx: ::std::os::raw::c_int,
        shut_tx: ::std::os::raw::c_int,
    ) -> err_t;
}
unsafe extern "C" {
    pub fn tcp_write(
        pcb: *mut tcp_pcb,
        dataptr: *const ::std::os::raw::c_void,
        len: u16_t,
        apiflags: u8_t,
    ) -> err_t;
}
unsafe extern "C" {
    pub fn tcp_setprio(pcb: *mut tcp_pcb, prio: u8_t);
}
unsafe extern "C" {
    pub fn tcp_output(pcb: *mut tcp_pcb) -> err_t;
}
unsafe extern "C" {
    pub fn tcp_debug_state_str(s: tcp_state) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tcp_tmr();
}
unsafe extern "C" {
    pub fn tcp_slowtmr();
}
unsafe extern "C" {
    pub fn tcp_fasttmr();
}
unsafe extern "C" {
    pub fn tcp_input(p: *mut pbuf, inp: *mut netif);
}
unsafe extern "C" {
    pub fn tcp_alloc(prio: u8_t) -> *mut tcp_pcb;
}
unsafe extern "C" {
    pub fn tcp_abandon(pcb: *mut tcp_pcb, reset: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn tcp_send_empty_ack(pcb: *mut tcp_pcb) -> err_t;
}
unsafe extern "C" {
    pub fn tcp_rexmit(pcb: *mut tcp_pcb);
}
unsafe extern "C" {
    pub fn tcp_rexmit_rto(pcb: *mut tcp_pcb);
}
unsafe extern "C" {
    pub fn tcp_rexmit_fast(pcb: *mut tcp_pcb);
}
unsafe extern "C" {
    pub fn tcp_update_rcv_ann_wnd(pcb: *mut tcp_pcb) -> u32_t;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_hdr {
    pub src: u16_t,
    pub dest: u16_t,
    pub seqno: u32_t,
    pub ackno: u32_t,
    pub _hdrlen_rsvd_flags: u16_t,
    pub wnd: u16_t,
    pub chksum: u16_t,
    pub urgp: u16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_hdr"][::std::mem::size_of::<tcp_hdr>() - 20usize];
    ["Alignment of tcp_hdr"][::std::mem::align_of::<tcp_hdr>() - 1usize];
    ["Offset of field: tcp_hdr::src"][::std::mem::offset_of!(tcp_hdr, src) - 0usize];
    ["Offset of field: tcp_hdr::dest"][::std::mem::offset_of!(tcp_hdr, dest) - 2usize];
    ["Offset of field: tcp_hdr::seqno"][::std::mem::offset_of!(tcp_hdr, seqno) - 4usize];
    ["Offset of field: tcp_hdr::ackno"][::std::mem::offset_of!(tcp_hdr, ackno) - 8usize];
    ["Offset of field: tcp_hdr::_hdrlen_rsvd_flags"]
        [::std::mem::offset_of!(tcp_hdr, _hdrlen_rsvd_flags) - 12usize];
    ["Offset of field: tcp_hdr::wnd"][::std::mem::offset_of!(tcp_hdr, wnd) - 14usize];
    ["Offset of field: tcp_hdr::chksum"][::std::mem::offset_of!(tcp_hdr, chksum) - 16usize];
    ["Offset of field: tcp_hdr::urgp"][::std::mem::offset_of!(tcp_hdr, urgp) - 18usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_seg {
    pub next: *mut tcp_seg,
    pub p: *mut pbuf,
    pub len: u16_t,
    pub flags: u8_t,
    pub tcphdr: *mut tcp_hdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_seg"][::std::mem::size_of::<tcp_seg>() - 32usize];
    ["Alignment of tcp_seg"][::std::mem::align_of::<tcp_seg>() - 8usize];
    ["Offset of field: tcp_seg::next"][::std::mem::offset_of!(tcp_seg, next) - 0usize];
    ["Offset of field: tcp_seg::p"][::std::mem::offset_of!(tcp_seg, p) - 8usize];
    ["Offset of field: tcp_seg::len"][::std::mem::offset_of!(tcp_seg, len) - 16usize];
    ["Offset of field: tcp_seg::flags"][::std::mem::offset_of!(tcp_seg, flags) - 18usize];
    ["Offset of field: tcp_seg::tcphdr"][::std::mem::offset_of!(tcp_seg, tcphdr) - 24usize];
};
unsafe extern "C" {
    pub static mut tcp_input_pcb: *mut tcp_pcb;
}
unsafe extern "C" {
    pub static mut tcp_ticks: u32_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_listen_pcbs_t {
    pub listen_pcbs: *mut tcp_pcb_listen,
    pub pcbs: *mut tcp_pcb,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_listen_pcbs_t"][::std::mem::size_of::<tcp_listen_pcbs_t>() - 8usize];
    ["Alignment of tcp_listen_pcbs_t"][::std::mem::align_of::<tcp_listen_pcbs_t>() - 8usize];
    ["Offset of field: tcp_listen_pcbs_t::listen_pcbs"]
        [::std::mem::offset_of!(tcp_listen_pcbs_t, listen_pcbs) - 0usize];
    ["Offset of field: tcp_listen_pcbs_t::pcbs"]
        [::std::mem::offset_of!(tcp_listen_pcbs_t, pcbs) - 0usize];
};
unsafe extern "C" {
    pub static mut tcp_bound_pcbs: *mut tcp_pcb;
}
unsafe extern "C" {
    pub static mut tcp_listen_pcbs: tcp_listen_pcbs_t;
}
unsafe extern "C" {
    pub static mut tcp_active_pcbs: *mut tcp_pcb;
}
unsafe extern "C" {
    pub static mut tcp_tw_pcbs: *mut tcp_pcb;
}
unsafe extern "C" {
    pub static mut tcp_tmp_pcb: *mut tcp_pcb;
}
unsafe extern "C" {
    pub fn tcp_pcb_copy(pcb: *mut tcp_pcb) -> *mut tcp_pcb;
}
unsafe extern "C" {
    pub fn tcp_pcb_purge(pcb: *mut tcp_pcb);
}
unsafe extern "C" {
    pub fn tcp_pcb_remove(pcblist: *mut *mut tcp_pcb, pcb: *mut tcp_pcb);
}
unsafe extern "C" {
    pub fn tcp_segs_free(seg: *mut tcp_seg);
}
unsafe extern "C" {
    pub fn tcp_seg_free(seg: *mut tcp_seg);
}
unsafe extern "C" {
    pub fn tcp_seg_copy(seg: *mut tcp_seg) -> *mut tcp_seg;
}
unsafe extern "C" {
    pub fn tcp_send_fin(pcb: *mut tcp_pcb) -> err_t;
}
unsafe extern "C" {
    pub fn tcp_enqueue_flags(pcb: *mut tcp_pcb, flags: u8_t) -> err_t;
}
unsafe extern "C" {
    pub fn tcp_rexmit_seg(pcb: *mut tcp_pcb, seg: *mut tcp_seg);
}
unsafe extern "C" {
    pub fn tcp_rst(
        seqno: u32_t,
        ackno: u32_t,
        local_ip: *mut ip_addr_t,
        remote_ip: *mut ip_addr_t,
        local_port: u16_t,
        remote_port: u16_t,
    );
}
unsafe extern "C" {
    pub fn tcp_next_iss() -> u32_t;
}
unsafe extern "C" {
    pub fn tcp_keepalive(pcb: *mut tcp_pcb);
}
unsafe extern "C" {
    pub fn tcp_zero_window_probe(pcb: *mut tcp_pcb);
}
unsafe extern "C" {
    pub fn tcp_eff_send_mss(sendmss: u16_t, addr: *mut ip_addr_t) -> u16_t;
}
unsafe extern "C" {
    pub fn tcp_recv_null(
        arg: *mut ::std::os::raw::c_void,
        pcb: *mut tcp_pcb,
        p: *mut pbuf,
        err: err_t,
    ) -> err_t;
}
unsafe extern "C" {
    #[doc = " External function (implemented in timers.c), called when TCP detects\n that a timer is needed (i.e. active- or time-wait-pcb found)."]
    pub fn tcp_timer_needed();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
